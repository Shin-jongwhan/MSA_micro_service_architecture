### 241219
## saga pattern
### MSA 환경에서 사용하고 다양한 서비스들이 맞물려 있는 환경, 분산 환경에서 각 트랜잭션을 관리하기 위한 '트랜잭션 방법론'이다.
### <br/><br/><br/>


## local vs compensation transaction
- 로컬(local) : 하나의 서비스 단위 별로 관리하는 것
- 보상(compensation) : 1, 2, 3, 4단계 별로 기능(또는 프로세스, 워크플로우 등...)이 진행되어야 하고 각 단계에서 실패했을 때 이전 단계의 트랜잭션을 관리해야 할 때 사용<br/>
여러 기능 단위인 로컬 트랜잭션(각 서비스)을 하나로 묶어 관리한다고 보면 된다.
### <br/>

### 기본적으로 보상 트랜잭션은 '중앙 관리'이다. 그리고 중앙 관리 방법은 크게 2가지로 나뉜다.
- 중앙 집중 처리 : 중앙에서 연결된 모든 서비스들을 관리한다. 상위 단계에서 실패하면 하위 단계를 보상(delete 등...)하여 데이터의 일관성을 보장한다.
- 구독형 : 메세지 브로커를 이용하여 구독하여 관리한다. 어떤 서비스 단위(여러 서비스들이 묶인 단위)로 구독해서 보상이 필요할 때 사용한다.
### <br/>

### 단점
#### 보상 트랜잭션은 중앙 관리이기 때문에 별도의 기능을 하나 더 두어야 한다. 또는 메세지 브로커를 관리해야 한다.
#### 그래서 DevOps 관점에서는 유지보수해야 할 것이 늘어난다.
#### 하지만 세심한 orchastration을 구현하고 관리하려면 보상 트랜잭션은 아주 강력한 방법이 된다.
#### <br/>

#### 이를 로컬 트랜잭션으로도 충분히 구현할 수도 있는데, 하지만 독립성이 떨어진다. 상호 연결관계를 형성할 수 밖에 없다(필연적).
#### <br/>

#### 그리고 보상 트랜잭션을 사용할 때는 기능(또는 서비스)의 단위를 잘 묶어서 트랜잭션을 구현해야 한다. 
#### 안 그러면 성능상 큰 단점이 된다. 
#### 보상 트랜잭션은 commit, rollback을 직접적으로 이용하는 게 아니다. 실제 트랜잭션은 각 기능 단위(또는 서비스) 별로 이루어지는 것이고, 실패할 경우 이전 단계를 삭제하는 등의 트래픽을 어쨌든 일으켜야 한다.
#### 트래픽을 일으키기 때문에 다음의 방법으로 충분히 보완을 해서 사용해야 한다.
- 데이터 사전 분석 : 보상 트랜잭션 단위를 일으키기 전에 데이터를 충분히 분석한다. 에러를 일으킬 확률을 사전에 줄인다. 이렇게 되면 트래픽 발생을 최소화할 수 있다.
- 밀집도 있는 기능 단위 : 기능 별로 좀 더 밀집도 있게 구성한다. 예를 들어보겠다. 한 기능 단위가 1부터 100까지 있는 것이 있고, 이걸 잘 정리해서 5개로 줄인 것이 있다고 해보자. 뭐가 낫겠는가.
### <br/><br/><br/>

## MSA 관점
### 위에서 `밀집도 있는 기능 단위`는 아주 중요하다.
### 이는 최근에 MSA로 구성된 아키텍처에서 큰 문제점으로 인식되고 있고, MSA가 최근 유행하는 아키텍처라고 하지만 유지보수나 기능(서비스)들의 결합에 대한 복잡성 문제로 다시 아키텍처를 바꾸는 경우들도 있다.
### 또한 네트워크 상의 문제점도 있다. 각 서비스들은 독립성을 유지하기 위해 서버들을 분리해서 관리한다거나, 서비스 별로 컨테이너를 관리한다거나... 엄청 커지면 또 이게 문제다.
### 이를 해결하기 위해서는 기능 상 밀집도 있게 묶는 작업이 정말 중요하다.
